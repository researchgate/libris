<?php
/**
 * This is a library for parsing RIS files.
 *
 * LibRIS::RISReader() is the main parser.
 * LibRIS::RISWriter() can generate RIS data.
 * LibRIS::RISTags() contains useful RIS information.
 *
 * @see http://www.refman.com/support/risformat_intro.asp
 */

namespace LibRIS;

/**
 * The main class for parsing RIS files.
 *
 * Usage:
 * @code
 * <?php
 *
 * use \LibRIS\RISReader;
 *
 * $reader = new RISReader();
 *
 * // Parse a file of RIS data.
 * $reader->parseFile('path/to/file.ris');
 *
 * // Parse a string containing RIS data.
 * $reader->parseString($someRisString);
 *
 * // Parse an array of lines.
 * $reader->parseArray($arrayOfRISDirectives);
 *
 * // Get an associative array of records.
 * $array = $reader->getRecords();
 *
 * // Dump the records to STDOUT
 * $reader->printRecords();
 *
 * ?>
 * @endcode
 *
 * The data structure generated by this class is of the form
 * @code
 * <?php
 * array(
 *   [0] => array(
 *     'T1' => array('title one', 'title 2'),
 *     'TY' => array('JOUR'),
 *     // Other tags and their values.
 *   ),
 *   [1] => array(
 *     'T1' => array('another entry'),
 *     'TY' => array('JOUR'),
 *   ),
 * );
 * ?>
 * @endcode
 */
class RISReader
{
    public const RIS_EOL = "\r\n";
    public const LINE_REGEX = '/^(([A-Z1-9]{2})\s+-(.*))|(.*)$/';

    protected ?array $data = null;

    /**
     * Parse an RIS file.
     *
     * This will parse the file and return a data structure representing the
     * record.
     *
     * @param string $filename
     *  The full path to the file to parse.
     * @param resource $context
     *  The stream context (in desired) for handling the file.
     */
    public function parseFile(string $filename, $context = null): void
    {
        if (!is_file($filename)) {
            throw new ParseException(sprintf('File %s not found.', htmlentities($filename)));
        }
        $flags = FILE_SKIP_EMPTY_LINES;

        /** @psalm-suppress PossiblyNullArgument */
        $contents = file($filename, $flags, $context);

        $this->parseArray($contents);
    }

    /**
     * Parse a string of RIS data.
     *
     * This will parse an RIS record into a representative data structure.
     *
     * @param string $string
     *  RIS-formatted data in a string.
     */
    public function parseString(string $string): void
    {
        $contents = explode(RISReader::RIS_EOL, $string);
        $this->parseArray($contents);
    }

    /**
     * Take an array of lines and parse them into an RIS record.
     *
     * @param string[] $lines
     */
    protected function parseArray(array $lines): void
    {
        $recordset = [];

        // Do any cleaning and normalizing.
        $this->cleanData($lines);

        $record = [];
        $lastTag = null;
        foreach ($lines as $line) {
            $line = trim($line);
            $matches = [];

            preg_match(self::LINE_REGEX, $line, $matches);
            if (!empty($matches[3])) {
                $lastTag = $matches[2];
                $record[$matches[2]][] = trim($matches[3]);
            }
            // End record and prep a new one.
            elseif (!empty($matches[2]) && $matches[2] === 'ER') {
                $lastTag = null;
                $recordset[] = $record;
                $record = [];
            } elseif (!empty($matches[4])) {
                // Append to the last one.
                // We skip leading info (like BOMs).
                if (!empty($lastTag)) {
                    /** @phan-suppress-next-line PhanTypeInvalidDimOffset */
                    $lastEntry = count($record[$lastTag]) - 1;
                    // We trim because some encoders add tabs or multiple spaces.
                    // Standard is silent on how this should be handled.
                    $record[$lastTag][$lastEntry] .= ' ' . trim($matches[4]);
                }
            }
        }
        if (!empty($record)) {
            $recordset[] = $record;
        }

        $this->data = $recordset;
    }

    public function getRecords(): ?array
    {
        return $this->data;
    }

    public function printRecords(): void
    {
        $format = "%s:\n\t%s\n";
        foreach ($this->data ?? [] as $record) {
            foreach ($record as $key => $values) {
                foreach ($values as $value) {
                    printf($format, RISTags::describeTag($key) ?? '', $value);
                }
            }

            print PHP_EOL;
        }
    }

    /**
     * Clean up the data before processing.
     *
     * @param array $lines
     *   Indexed array of lines of data.
     */
    protected function cleanData(array &$lines): void
    {
        if (empty($lines)) {
            return;
        }

        // Currently, we only need to strip a BOM if it exists.
        // Thanks to Derik Badman (http://madinkbeard.com/) for finding the
        // bug and suggesting this fix:
        // http://blog.philipp-michels.de/?p=32
        $first = $lines[0];
        if (substr($first, 0, 3) == pack('CCC', 0xef, 0xbb, 0xbf)) {
            $lines[0] = substr($first, 3);
        }
    }
}
